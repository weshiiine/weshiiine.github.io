# 概述
计算机是按照程序员事先编好的程序进行工作的
程序会被“翻译”（编译、汇编或解释）成一系列相应的指令，这些指令告诉计算机如何执行特定的任务
* 指令是计算机硬件能够理解和执行的基本命令。包括算术运算、逻辑运算、数据传送、跳转等
* 每条指令必须显式或隐式提供以下信息
	* 执行的操作
	* 操作数来源
	* 操作结果存放处
	* 下一条指令的地址（一般不需要显式给出）
一台计算机中所有指令的集合称为该计算机的指令集，也称**指令系统**
指令系统是计算机软硬件系统的设计基础
# 指令格式
## 指令的一般格式
| 操作码OP    | 地址码A              |
| -------- | ----------------- |
| 指明进行何种操作 | 指明相应操作数（可包含多个操作数） |
寻址方式可以显式包含在地址码字段，或隐式包含在操作码字段
指令字长：构成指令的二进制位数

| 定长指令系统                  | 变长指令系统                   |
| ----------------------- | ------------------------ |
| 指令长度固定                  | 指令长度可变                   |
| 结构简单。有利于指令顺序寻址、取指、译码    | 结构灵活，但给取指和译码带来不便（多次访存操作） |
| 硬件实现容易                  | 硬件实现难度大                  |
| 平均指令长度较长、冗余状态多（浪费存储器空间） | 平均指令长度较短、冗余状态少           |
| 受指令长度限制，很难扩展            | 不受指令长度限制，扩展性好            |
| RISC中常用，如MIPS系列         | CISC中常用，如Intel x86系列     |
由于存储器的基本编址单位为字节，而指令存储在存储器中，因此**指令字长都是字节的整数倍**
指令字长越长，占用主存空间越大，访存时间越长
根据指令字长和机器字长的关系，指令可分为以下三类：
* 半字长指令 CPU一次访存，读2条
* 单字长指令 CPU一次访存，读1条
* 多字长指令 CPU多次访存
指令短可以提高速度
## 地址码字段
根据指令类型和寻址方式，地址码可能是：
* 操作数
* 操作数地址
	* 主存地址
	* 寄存器编号
	* 外部设备端口地址
	* 用于计算的地址偏移量

### 三地址指令

| 操作码OP | 地址码A1    | 地址码A2 | 地址码A3 |
| ----- | -------- | ----- | ----- |
|       | 源操作数1的地址 | --    | --    |
（A1）OP（A2）--> A3
### 二地址指令

| 操作码OP | 地址码A1    | 地址码A2 |
| ----- | -------- | ----- |
|       | 源操作数1的地址 | --    |
|       | 目的操作数的地址 |       |
（A1）OP（A2）--> A1
根据数据存储位置的不同，二地址指令可另分为RR、RS、SS
### 一地址指令

| 操作码OP | 地址码A     |
| ----- | -------- |
|       | 源操作数的地址  |
|       | 目的操作数的地址 |
OP（A）--> A

| 操作码OP | 地址码A    |
| ----- | ------- |
|       | 源操作数的地址 |
*(AL)* OP（A）--> *AX*
* AL：OP约定隐含于CPU某寄存器的另一个源操作数
* AX也是
* 如x86架构的Mul BL指令
### 零地址指令
指令本身不需要操作数
* 空地址NOP
* 停机指令HLT
* 程序返回指令RET
程序需要一个操作数，但该操作数隐含在某个寄存器中

## 操作码字段
操作码指定进行什么操作（运算）
根据操作码长度是否固定，可分为两种操作码
### 定长操作码
操作码长度固定，在指令中位置固定
译码简单，硬件实现简单
指令规模决定操作码位数：$log_2x \le n$ （x为指令数量，n为操作码位数）
### 变长操作码
长度可变，指令中的位置不固定
有效减少操作码平均长度，给地址码留出更多位数，增大寻址空间
常见实现方法：**扩展操作码技术**
#### 扩展操作码
核心思想：操作码长度随地址码字段中地址码数量的减少而增加
![[Pasted image 20241218152242.png]]
*短操作码不能作为长操作码的前缀*

# 寻址方式
## 概述
寻址方式指寻找**指令**或**指令中的操作数**的*有效地址*的方式
**有效地址**可以是*主存地址*，也可以是*虚拟地址*
![[Pasted image 20241218152630.png]]
除特别说明，寻址方式一般指操作数寻址方式
寻址方式是指令系统的重要组成部分，影响程序设计、程序运行速度和存储空间利用率
## 指令寻址方式
### 顺序寻址
通常情况下，程序的所有机器指令在主存中按顺序存放
大多数情况下，**程序按照指令序列顺序执行**
* 如果知道指令序列中第一条指令的有效地址，在该有效地址的基础上增加一条指令所占用主存单元的数量，就可以得到下一条指令的有效地址。这种寻找指令有效地址的方法就称为指令的顺序寻址。
![[Pasted image 20241218153417.png]]
采用顺序寻址方式，每读取一条指令，自动(PC)+1以算出下一条指令的有效地址（“1”：以字节为单位的指令字长）
### 跳跃寻址
执行分支指令或跳转指令时会改变指令执行顺序。此时就要采取跳跃寻址
* 分支指令用于**基于条件**改变指令序列的执行顺序
* 跳转指令用于**无条件**改变执行顺序
![[Pasted image 20241218153924.png]]

## 操作数寻址方式
不同指令可能采用不同的操作数寻址方式来获取操作数
可将指令格式中的地址码字段划分为以下两部分
* 寻址方式（寻址特征）字段M（位数取决于所要支持不同寻址方式的数量）
* 形式地址字段D
### 立即寻址
M表示立即寻址的特征码（如000）
D为操作数本身
立即寻址方式下，操作数与指令一起存放在主存
* 取指令时，**操作数随指令一起**被读取并送到CPU内的指令寄存器IR中
* 指令执行时，直接从指令寄存器中获取操作数，无需访问其他存储单元
特点：
- 取操作数快
- 形式地址D位宽有限，限制表示范围
- 一般用于变量赋初值
### 直接寻址
M表示立即寻址的特征码（如001）
D表示操作数的主存地址
直接寻址方式下，操作数与指令分开存放
* D直接给出了操作数的主存地址
* 指令执行时需要访问一次主存获取操作数
特点：
* 操作数地址直观，无需专门计算
* D位宽有限，限制寻址范围
* 操作数地址位于指令中，不方便修改
### 寄存器寻址
M表示寄存器寻址特征码（如010）
D表示操作数所在通用寄存器的编号
寄存器寻址方式下，操作数与指令分开存放。操作数存放在CPU内某个通用寄存器，指令存放在主存
* 取指令时，操作数不会随指令一起被读取并送到CPU内的指令寄存器IR中
* 指令执行时，只访问寄存器（不需要访问主存）
特点：
* 获取操作数不需要访问主存，执行速度快
* 由于通用寄存器数量少，所需形式地址D位数少，利于缩短指令字长，节省存储空间（同时不能为大量操作数提供存储服务（寄存器数量有限））
### 间接寻址
M表示间接寻址的特征码（如011）
D表示操作数的间接地址
间接寻址方式下，操作数与指令分开存放在主存。
* 指令中的形式地址D为间接地址，间接地址所指向的主存单元中的内容才是操作数的有效地址
* 取指令时，操作数不会随指令一起被读取并送到CPU内的指令寄存器IR中
* 取指令时需要访问两次主存获取操作数
>为什么这么麻烦？
>扩大存储空间

特点：
* 相较于直接寻址，能用较短形式D访问较大的主存空间
* 相较于直接寻址，需要修改操作数地址时不再需要修改指令中的形式地址D，只需要修改形式地址D指向的驻村单元即可
* 指令执行时需要访问两次主存，降低了指令执行速度
### 寄存器间接寻址
M表示寄存器间接寻址的特征码（如100）
D表示存放操作数地址的通用寄存器编号
寄存器间接寻址方式下，操作数与指令分开存放在主存
* D给出的通用寄存器的编号，内容是操作数的主存地址
* 取指令时，操作数不会随指令一起被读取并送到CPU内的指令寄存器IR中
* 指令执行时需要访问一次主存获取操作数
特点：
* 具有间接寻址优点，同时少访问一次主存
* 与寄存器寻址缺点类似，CPU内寄存器数量有限，不能为大量操作数提供存储主存地址的服务
---
![[Pasted image 20241218160649.png]]

---
### 相对寻址
M表示相对寻址的特征码（如101）
D表示相对于当前PC值的偏移量，用以形成操作数的主存地址
相对寻址方式下，操作数与指令分开存放在主存
* D是需要给程序计数器PC中的内容加上的偏移量，可正可负（补码表示），这样就可以形成操作数的主存地址或转移目标地址
* 取指令时，操作数不会随指令一起被读取并送到CPU内的指令寄存器IR中
* 指令译码或执行阶段，会计算操作数的主存地址或转移目标地址
特点和用途：
* 程序设计时只需给定指令与操作数之间的相对距离，不必关心操作数在主存中的绝对地址，用于实现共享
* 代码的浮动
* 实现程序跳转执行
[[Pasted image 20241218161811.png|例题]]
### 变址寻址
![[Pasted image 20241218161948.png]]
变址寻址方式下，操作数与指令分开存放在主存
* 指令中的寄存器编号n，指明使用CPU内部哪个寄存器(通用寄存器或专用寄存器)，来存放变化的地址，该寄存器称为变址寄存器，其内部存放的地址与形式地址D相加，即可得到操作数的主存地址。
* 取指令时，操作数不会随指令一起被读取并送到CPU内的指令寄存器IR中
* 指令执行时需要访问一次主存获取操作数
![[Pasted image 20241218162156.png]]
特点和用途：
* 变址寄存器n的内容可变，而形式地址D的值设定后在指令执行过程中将保持不变。变址寄存器n的位数大于形式地址D的位数，扩大了寻址范围(可表示整个存储空间)
* 主要应用于数组元素的访问，首地址赋值给指令中的形式地址D，使变址寄存器n的值按顺序变化，就可以对数组各元素进行相同的操作
### 基址寻址
![[Pasted image 20241218162450.png]]
形式上与变址寻址相同
[[Pasted image 20241218162959.png|区别]]：

|      | 操作码OP | 寻址方式M |  寄存器编号n   | 形式地址D |                   |
| :--: | :---: | :---: | :-------: | :---: | ----------------- |
| 变址寻址 |       |       | 变址寄存器内容可变 | 值保持不变 | 面向用户，主要用于处理程序循环问题 |
| 基质寻址 |       |       | 基址寄存器内容不变 |  值可变  | 面向系统，主要用于程序的重定位   |
此外二者寻址过程完全相同

![[031f514a376acfaf91bc955c2ebddc15.jpg]]
### 堆栈寻址
