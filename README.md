# weshiiine.github.io

# 基本概念
进程需要操作系统的支持——进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的地址空间
## 进程类型
* 低级通信
* 高级通信
## 通信方式
### 数据格式
* 字节格式：接收方不保留各次发送之间的分界
* 报文格式：接收方保留各次发送之间的分界，分成定长/不定长 报文和可靠/不可靠 报文
### 同步方式
* 阻塞操作：操作方要等待操作结束
* 不阻塞操作：操作提交后立即返回
## 进程同步与异步
[[2.4 进程联系#^8cdc25|进程同步与异步]]指在并发系统中，多个进程间的消息通信机制
## 进程阻塞与非阻塞
**阻塞与非阻塞**重点在于进程等待消息时候的行为，关注的是**发起并行调度**的**主调进程**
* 阻塞：调用发出后，消息返回前进程挂起
* 非阻塞：调用发出后。不会阻塞当前进程，立即返回

>例：老张爱喝茶，煮开水
出场人物：老张，水壶两把（普通水壶，响水壶）
老张把水壶放到火上，立等水开（**同步阻塞**）
老张觉得自己有点傻
老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有（**同步非阻塞**）
___
>老张还是觉得自己有点傻，于是买了把会响笛的水壶
老张把响水壶放到火上，立等水开（**异步阻塞**）
老张觉得这样傻等意义不大，老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶（**异步非阻塞**）

**调用进程**，决定了是**阻塞**还是**非阻塞**；调用进程一直等则为阻塞
**被调用进程**，决定了是**同步**还是**异步**，有结果时再返回是**同步**，立马返回无结果，结果另行通知是**异步**
# 低级通信
## 机制原理
* 每个信号都对应正整数常量，即信号编号，每一个正整数代表一个特定的信号
* 进程间传送事先约定的信息类型，用于通知进程发生了某异常事件
* 进程通过信号机制检查是否有信号。若有则中断正在执行的程序，转向对应的处理程序；结束后返回断点继续执行，这是一种**软中断**
## 信号收发
* **发送信号**：发送信号的程序用系统调用**kill( )** 实现（大多信号都是把另一个进程杀死）
* 接收信号：为每个进程内嵌相应的接受函数
* 接受之后：预置信号处理，**接收信号**的程序用**signal( )** 实现对处理方式的调用 
## 实例
### 1. kill( )
`int kill ( pid, sig )`
pid是接受进程的标识符，参数sig是要发送的软中断信号
1. pid > 0 时，发送信号给具有该pid的**单个进程**
2. pid = 0 时，发送信号给与发送进程**同组**的所有进程
3. pid = -1 时，表示发送信号给除了调用进程和init进程(pid为1)以外的所有进程
### 2.signal( )
`signal(sig,function)`
```c
#include <signal.h> 
//头文件

int sig;
void (*func)()
//参数定义
//捕捉信号sig后，执行function规定的操作

```
1. function=1，屏蔽该类信号
2. function=0，接收到sig信号后终止自己
3. function$\ne 0，\ne1$ 时，作为指向处理函数的指针

|   值   |   名字    |        说明         |
| :---: | :-----: | :---------------: |
|  01   | SIGHUP  |        挂起         |
|  02   | SIGINT  | 中断，当用户按^c或^break时 |
| ..... |         |                   |
|  16   | SIGUSR1 |     用户自定义信号1      |
|  17   | SIGUSR2 |     用户自定义信号2      |
[[Pasted image 20241209133349.png|信号通信详表]]
### 3. fork( )
* fork=0：在子进程中，pid变量保存的fork( )返回值为0，表示当前进程是子进程
* fork>0：在父进程中，pid变量保存的fork( )返回值为子进程的id值（进程唯一标识符）
* fork=-1：创建失败
# 高级通信
## 共享存储
### 原理：
利用内存中间的一个共享存储区，实现两个进程间的通信（把进程间通信转换为对内存中数据的读写操作，效率最高）
### 函数调用
1. shmget( )
创建、获得一个共享存储区
`shmid=shmget(key,size,flag)`
	* key是共享存储区的名字
	* size是其大小（单位为字节）
	* flag是用户设置的标志
	* 返回shmid值给其他函数使用
	* 进程创建后再次调用shmget就是获得刚刚创建的共享存储区，不会重复创建
2. shmat( )
共享存储区附接，将共享存储区**附接**进程虚拟地址空间
`virtaddr = shmat(shmid,addr,flag)`
	* shmid是共享存储区的标识符
	* addr时用户给定，将共享存储区附接到进程的虚地址空间
	* flag规定读写权限，值为0时可读可写
	* 返回值是共享存储区所附接到的进程虚地址viraddr
3. shmdt( )
把共享存储区从进程虚地址空间**断开**
`shmdt(addr)`
	* addr是要断开连接的虚地址，即由shmat( )所返回的虚地址
	* 调用成功返回0，否则返回-1
4. shmctl( )
共享存储的控制，对其状态进行读取和修改
`shmctl(shmid,cmd,buf)`
	* shmid：共享存储区的标识符
	* cmd：操作命令
		* **查询**共享存储区的情况（长度、连接进程数....）
		* **设置或改变**共享存储区的属性
		* 共享存储的**加锁解锁**，**删除**共享存储区标识符
	* buf：用户缓冲区地址
